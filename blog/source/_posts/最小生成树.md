---
title: 最小生成树
date: 2024-05-22 17:05:34
---


### 一、常用模板

#### 1、Kruskal
```c++
// https://www.luogu.com.cn/problem/P3366
using namespace std;
constexpr int maxn = 1000010;
int F[maxn];
int Find(int x){
    return x == F[x] ? x : F[x] = Find(F[x]);
}
struct E{
    int a, b, w;
    bool operator <(const E& e) const{
        return w < e.w;
    }
} edges[maxn];
int main(){
    int n, m;
    scanf("%d%d",&n, &m);
    for(int i = 1; i <= n; ++i) F[i] = i;
    for(int i = 1; i <= m; ++i){
        scanf("%d%d%d", &edges[i].a, &edges[i].b, &edges[i].w);
    }
    sort(edges + 1, edges + 1 + m);
    long long int ans = 0;
    int cnt = 0;
    for(int i = 1; i <= m; ++i){
        int fa = Find(edges[i].a);
        int fb = Find(edges[i].b);
        if(fa ^ fb){
            ans += edges[i].w;
            F[fb] = fa;
            ++cnt;
            if(cnt == n - 1) break;
        }
    }
    if(cnt == n - 1) printf("%lld\n", ans);
    else printf("orz\n");
    return 0;
}

```

#### 2、最小生成树的唯一性
对于 Kruskal 算法，只要计算为当前权值的边可以放几条，实际放了几条，如果这两个值不一样，那么就说明这几条边与之前的边产生了一个环（这个环中至少有两条当前权值的边，否则根据并查集，这条边是不能放的），即最小生成树不唯一。
```c++
// POJ-1679
using namespace std;
const int maxn = 1000010;
int F[maxn];
int Find(int x){
    return x == F[x] ? x : F[x] = Find(F[x]);
}
struct E{
    int a, b, w;
    bool operator <(const E& e) const{
        return w < e.w;
    }
} edges[maxn];
int solve(){
    int n, m;
    scanf("%d%d",&n, &m);
    for(int i = 1; i <= n; ++i) F[i] = i;
    for(int i = 1; i <= m; ++i){
        scanf("%d%d%d", &edges[i].a, &edges[i].b, &edges[i].w);
    }
    sort(edges + 1, edges + 1 + m);
    long long int ans = 0;
    int cnt = 0, s1 = 0, s2 = 0, last = 0;
    bool flag = true;
    for(int i = 1; i <= m; ++i){
        if(i > last){
            if(s1 != s2){
                flag = false;
                break;
            }
            s2 = s1 = 0;
            for(int j = i; j <= m; ++j){
                if(edges[i].w == edges[j].w)
                    last = j, s1 += Find(edges[j].a) != Find(edges[j].b);
                else break;
            }
        }

        int fa = Find(edges[i].a);
        int fb = Find(edges[i].b);
        if(fa ^ fb){
            ans += edges[i].w;
            F[fb] = fa;
            ++cnt;
            ++s2;
        }
    }
    if(flag && s1 == s2) printf("%lld\n", ans);
    else printf("Not Unique!\n");
    return 0;
}

int main(){
    int T;
    scanf("%d", &T);
    while(T--) solve();
    return 0;
}
```
