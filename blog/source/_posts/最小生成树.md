---
title: 最小生成树
date: 2024-05-22 17:05:34
---


### 一、常用模板

#### 1、Kruskal
```c++
// https://www.luogu.com.cn/problem/P3366
using namespace std;
constexpr int maxn = 1000010;
int F[maxn];
int Find(int x){
    return x == F[x] ? x : F[x] = Find(F[x]);
}
struct E{
    int a, b, w;
    bool operator <(const E& e) const{
        return w < e.w;
    }
} edges[maxn];
int main(){
    int n, m;
    scanf("%d%d",&n, &m);
    for(int i = 1; i <= n; ++i) F[i] = i;
    for(int i = 1; i <= m; ++i){
        scanf("%d%d%d", &edges[i].a, &edges[i].b, &edges[i].w);
    }
    sort(edges + 1, edges + 1 + m);
    long long int ans = 0;
    int cnt = 0;
    for(int i = 1; i <= m; ++i){
        int fa = Find(edges[i].a);
        int fb = Find(edges[i].b);
        if(fa ^ fb){
            ans += edges[i].w;
            F[fb] = fa;
            ++cnt;
            if(cnt == n - 1) break;
        }
    }
    if(cnt == n - 1) printf("%lld\n", ans);
    else printf("orz\n");
    return 0;
}

```
