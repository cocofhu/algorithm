---
title: 图的连通性
date: 2023-11-28 20:19:31
---


### 一、模板

#### 1、Tarjan 求无向图的桥

```c++
const int maxn = 200100;
int dfn[maxn], low[maxn], tdf = 0;

struct Edge {
    int next, to;
} edges[maxn];
int heads[maxn], pos = 0;

void addEdge(int a, int b) {
    edges[++pos].next = heads[a];
    edges[pos].to = b;
    heads[a] = pos;
}
// Tarjan 求无向图的桥
void tarjan0(int u, int fa) {
    low[u] = dfn[u] = ++tdf;
    for (int i = heads[u]; i; i = edges[i].next) {
        int v = edges[i].to;
        if (v == fa) continue;
        if (!dfn[v]) {
            tarjan0(v, u);
            low[u] = min(low[u], low[v]);
            if (low[v] > dfn[u]) {
                // bridge u - v
            }
        }
        else low[u] = min(low[u], dfn[v]);
    }
}
```
#### 2、Tarjan无向图求割点
```c++
const int maxn = 100100;
int dfn[maxn], low[maxn], tdf = 0;
int heads[maxn], pos = 0;
struct Edge {
    int next, to;
} edges[maxn * 2];

void addEdge(int a, int b) {
    //printf("edge: %d => %d\n", a, b);
    edges[++pos].next = heads[a];
    edges[pos].to = b;
    heads[a] = pos;
}
// 无向图求割点(割点无需判断反向边)
int cut[maxn];
void tarjan1(int u, bool root) {
    low[u] = dfn[u] = ++tdf;
    int cnt = 0;
    for (int i = heads[u]; i; i = edges[i].next) {
        int v = edges[i].to;
        if (!dfn[v]) {
            tarjan1(v, false);
            low[u] = min(low[u], low[v]);
            if (low[v] >= dfn[u])
                if (!root || ++cnt > 1) cut[u] = 1;
        }
        else low[u] = min(low[u], dfn[v]);
    }
}
```

#### 3、Tarjan无向图V-DCC缩点
```c++
const int maxn = 100100;
struct Edge {
    int next, to;
} edges[maxn * 2];
int heads[maxn], pos = 0;

void addEdge(int a, int b) {
    edges[++pos].next = heads[a];
    edges[pos].to = b;
    heads[a] = pos;
}

// 无向图vdcc(PS 割点无需判断前向fa是否为反向边)
int dfn[maxn], low[maxn], tdf = 0;
int cut[maxn];
stack<int> st;
vector<int> vdcc[maxn];
int dccn = 0;
void tarjan1(int u, bool root) {
    low[u] = dfn[u] = ++tdf;
    st.push(u);
    int cnt = 0;
    for (int i = heads[u]; i; i = edges[i].next) {
        int v = edges[i].to;
        if (!dfn[v]) {
            tarjan1(v, false);
            low[u] = min(low[u], low[v]);
            if (low[v] >= dfn[u]) {
                if (!root || ++cnt > 1) cut[u] = 1;
                vdcc[dccn].clear();
                while (1) {
                    int z = st.top(); st.pop();
                    vdcc[dccn].push_back(z);
                    if (v == z) break;
                }
                vdcc[dccn++].push_back(u);
            }
        }
        else {
            low[u] = min(low[u], dfn[v]);
        }
    }
}
```

#### 4、Tarjan有向图SCC缩点
```c++
// 无向图求SCC
int instk[maxn];
int stk[maxn], sp = -1;
// scc[u] 强联通分量号
// sccn[i] 强联通分量号i含有的节点个数
// cnt 强联通分量个数
int scc[maxn], sccn[maxn], cnt = 0;
void tarjan(int u) {
    low[u] = dfn[u] = ++tdf;
    stk[++sp] = u, instk[u] = 1;
    for (int i = heads[u]; i; i = edges[i].next) {
        int v = edges[i].to;
        if (!dfn[v])
            tarjan(v),
            low[u] = min(low[u], low[v]);
        else if(instk[v])
            low[u] = min(low[u], dfn[v]);
    }
    if(dfn[u] == low[u]){
        int v; sccn[++cnt] = 0;
        do{
            v = stk[sp--];
            instk[v] = 0;
            scc[v] = cnt;
            ++sccn[cnt];
        }while(u != v);
    }
}

```

#### 5、Tarjan无向图E-DCC缩点
```c++
#define _CRT_SECURE_NO_WARNINGS
// https://www.luogu.com.cn/problem/P8436
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <cstdlib>
#include <ctime>
#include <vector>
#include <queue>
#include <set>
#include <map>
#include <stack>
#include <numeric>
#include <string>
#include <bitset>
//#include <unordered_map>
//#include <unordered_set>

using namespace std;

const int maxn = 500100;

int heads[maxn], pos = 1;
struct Edge {
    int next, to;
} edges[1000010 * 4];
void addEdge(int a, int b) {
    edges[++pos].next = heads[a];
    edges[pos].to = b;
    heads[a] = pos;
}

int dfn[maxn], low[maxn], tdf = 0;
int e_dcc[maxn], e_dcc_stk[maxn], e_dcc_cnt = 0, e_dcc_sp = -1;
void tarjan(int u, int fa) {
    low[u] = dfn[u] = ++tdf; e_dcc_stk[++e_dcc_sp] = u;
    for (int i = heads[u]; i; i = edges[i].next) {
        int v = edges[i].to;
        if (i == (fa ^ 1)) continue;
        if (!dfn[v]) tarjan(v, i), low[u] = min(low[u], low[v]);
        else low[u] = min(low[u], dfn[v]);
    }
    if (dfn[u] == low[u]) {
        ++e_dcc_cnt;
        while (1) {
            int v = e_dcc_stk[e_dcc_sp--];
            e_dcc[v] = e_dcc_cnt;
            if (u == v) break;
        }
    }
}

int main() {
    int n = 0, m = 0;
    while (~scanf("%d%d", &n, &m)) {
        memset(heads, 0, sizeof(heads));
        memset(dfn, 0, sizeof(dfn));
        memset(low, 0, sizeof(low));
        e_dcc_cnt = tdf = 0;
        pos = 1;
        e_dcc_sp = -1;
        for (int i = 0; i < m; ++i) {
            int u, v;
            scanf("%d%d", &u, &v);
            addEdge(u, v);
            addEdge(v, u);

        }
        for (int i = 1; i <= n; ++i) {
            if (!dfn[i]) tarjan(i, 0);
        }
        vector<vector<int>> e_dcc_set(e_dcc_cnt);
        for (int u = 1; u <= n; ++u) {
            e_dcc_set[e_dcc[u] - 1].push_back(u);
        }
        printf("%d\n", e_dcc_cnt);
        for(int i = 0; i < e_dcc_cnt; ++i){
            printf("%d", (int)e_dcc_set[i].size());
            for(int v : e_dcc_set[i]) printf(" %d", v);
            puts("");
        }
    }
    return 0;
}
```
