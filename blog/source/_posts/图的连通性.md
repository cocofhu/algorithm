---
title: 图的连通性
date: 2023-11-28 20:19:31
---


### 一、模板

#### 1、Tarjan 求无向图的桥

```c++
const int maxn = 200100;
int dfn[maxn], low[maxn], tdf = 0;

struct Edge {
    int next, to;
} edges[maxn];
int heads[maxn], pos = 0;

void addEdge(int a, int b) {
    edges[++pos].next = heads[a];
    edges[pos].to = b;
    heads[a] = pos;
}
// Tarjan 求无向图的桥
void tarjan0(int u, int fa) {
    low[u] = dfn[u] = ++tdf;
    for (int i = heads[u]; i; i = edges[i].next) {
        int v = edges[i].to;
        if (v == fa) continue;
        if (!dfn[v]) {
            tarjan0(v, u);
            low[u] = min(low[u], low[v]);
            if (low[v] > dfn[u]) {
                // bridge u - v
            }
        }
        else low[u] = min(low[u], dfn[v]);
    }
}
```
#### 2、Tarjan无向图求割点
```c++
const int maxn = 100100;
int dfn[maxn], low[maxn], tdf = 0;
int heads[maxn], pos = 0;
struct Edge {
    int next, to;
} edges[maxn * 2];

void addEdge(int a, int b) {
    //printf("edge: %d => %d\n", a, b);
    edges[++pos].next = heads[a];
    edges[pos].to = b;
    heads[a] = pos;
}
// 无向图求割点(割点无需判断反向边)
int cut[maxn];
void tarjan1(int u, bool root) {
    low[u] = dfn[u] = ++tdf;
    int cnt = 0;
    for (int i = heads[u]; i; i = edges[i].next) {
        int v = edges[i].to;
        if (!dfn[v]) {
            tarjan1(v, false);
            low[u] = min(low[u], low[v]);
            if (low[v] >= dfn[u])
                if (!root || ++cnt > 1) cut[u] = 1;
        }
        else low[u] = min(low[u], dfn[v]);
    }
}
```

#### 3、Tarjan无向图V-DCC缩点
```c++
const int maxn = 100100;
struct Edge {
    int next, to;
} edges[maxn * 2];
int heads[maxn], pos = 0;

void addEdge(int a, int b) {
    edges[++pos].next = heads[a];
    edges[pos].to = b;
    heads[a] = pos;
}

// 无向图vdcc(PS 割点无需判断前向fa是否为反向边)
int dfn[maxn], low[maxn], tdf = 0;
int cut[maxn];
stack<int> st;
vector<int> vdcc[maxn];
int dccn = 0;
void tarjan1(int u, bool root) {
    low[u] = dfn[u] = ++tdf;
    st.push(u);
    int cnt = 0;
    for (int i = heads[u]; i; i = edges[i].next) {
        int v = edges[i].to;
        if (!dfn[v]) {
            tarjan1(v, false);
            low[u] = min(low[u], low[v]);
            if (low[v] >= dfn[u]) {
                if (!root || ++cnt > 1) cut[u] = 1;
                vdcc[dccn].clear();
                while (1) {
                    int z = st.top(); st.pop();
                    vdcc[dccn].push_back(z);
                    if (v == z) break;
                }
                vdcc[dccn++].push_back(u);
            }
        }
        else {
            low[u] = min(low[u], dfn[v]);
        }
    }
}
```

#### 4、Tarjan有向图SCC


#### 5、Tarjan无向图E-DCC

