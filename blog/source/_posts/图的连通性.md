---
title: 图的连通性
date: 2023-11-28 20:19:31
---


### 一、模板

#### 1、Tarjan 求无向图的桥

```c++
const int maxn = 200100;
int dfn[maxn], low[maxn], tdf = 0;

struct Edge {
    int next, to;
} edges[maxn];
int heads[maxn], pos = 0;

void addEdge(int a, int b) {
    edges[++pos].next = heads[a];
    edges[pos].to = b;
    heads[a] = pos;
}
// Tarjan 求无向图的桥
void tarjan0(int u, int fa) {
    low[u] = dfn[u] = ++tdf;
    for (int i = heads[u]; i; i = edges[i].next) {
        int v = edges[i].to;
        if (v == fa) continue;
        if (!dfn[v]) {
            tarjan0(v, u);
            low[u] = min(low[u], low[v]);
            if (low[v] > dfn[u]) {
                // bridge u - v
            }
        }
        else low[u] = min(low[u], dfn[v]);
    }
}
```
#### 2、Tarjan无向图求割点
```c++
const int maxn = 100100;
int dfn[maxn], low[maxn], tdf = 0;
int heads[maxn], pos = 0;
struct Edge {
    int next, to;
} edges[maxn * 2];

void addEdge(int a, int b) {
    //printf("edge: %d => %d\n", a, b);
    edges[++pos].next = heads[a];
    edges[pos].to = b;
    heads[a] = pos;
}
// 无向图求割点(割点无需判断反向边)
int cut[maxn];
void tarjan1(int u, bool root) {
    low[u] = dfn[u] = ++tdf;
    int cnt = 0;
    for (int i = heads[u]; i; i = edges[i].next) {
        int v = edges[i].to;
        if (!dfn[v]) {
            tarjan1(v, false);
            low[u] = min(low[u], low[v]);
            if (low[v] >= dfn[u])
                if (!root || ++cnt > 1) cut[u] = 1;
        }
        else low[u] = min(low[u], dfn[v]);
    }
}
```

#### 3、Tarjan无向图V-DCC缩点
```c++
const int maxn = 100100;
struct Edge {
    int next, to;
} edges[maxn * 2];
int heads[maxn], pos = 0;

void addEdge(int a, int b) {
    edges[++pos].next = heads[a];
    edges[pos].to = b;
    heads[a] = pos;
}

// 无向图vdcc(PS 割点无需判断前向fa是否为反向边)
int dfn[maxn], low[maxn], tdf = 0;
int cut[maxn];
stack<int> st;
vector<int> vdcc[maxn];
int dccn = 0;
void tarjan1(int u, bool root) {
    low[u] = dfn[u] = ++tdf;
    st.push(u);
    int cnt = 0;
    for (int i = heads[u]; i; i = edges[i].next) {
        int v = edges[i].to;
        if (!dfn[v]) {
            tarjan1(v, false);
            low[u] = min(low[u], low[v]);
            if (low[v] >= dfn[u]) {
                if (!root || ++cnt > 1) cut[u] = 1;
                vdcc[dccn].clear();
                while (1) {
                    int z = st.top(); st.pop();
                    vdcc[dccn].push_back(z);
                    if (v == z) break;
                }
                vdcc[dccn++].push_back(u);
            }
        }
        else {
            low[u] = min(low[u], dfn[v]);
        }
    }
}
```

#### 4、Tarjan有向图SCC缩点
```c++
// 无向图求SCC
int instk[maxn];
int stk[maxn], sp = -1;
// scc[u] 强联通分量号
// sccn[i] 强联通分量号i含有的节点个数
// cnt 强联通分量个数
int scc[maxn], sccn[maxn], cnt = 0;
void tarjan(int u) {
    low[u] = dfn[u] = ++tdf;
    stk[++sp] = u, instk[u] = 1;
    for (int i = heads[u]; i; i = edges[i].next) {
        int v = edges[i].to;
        if (!dfn[v])
            tarjan(v),
            low[u] = min(low[u], low[v]);
        else if(instk[v])
            low[u] = min(low[u], dfn[v]);
    }
    if(dfn[u] == low[u]){
        int v; sccn[++cnt] = 0;
        do{
            v = stk[sp--];
            instk[v] = 0;
            scc[v] = cnt;
            ++sccn[cnt];
        }while(u != v);
    }
}

```

#### 5、Tarjan无向图E-DCC缩点
```c++
int edcc[maxn];
stack<int> stk;
int cnt = 0;
void tarjan0(int u, int fa) {
    low[u] = dfn[u] = ++tdf;
    for (int i = heads[u]; i; i = edges[i].next) {
        int v = edges[i].to;
        if (v == fa) continue;
        if (!dfn[v]) tarjan0(v, u), low[u] = min(low[u], low[v]);
        else low[u] = min(low[u], dfn[v]);
    }
    if (dfn[u] == low[u]) {
        ++cnt;
        while (1) {
            int v = stk.top();
            stk.pop();
            edcc[v] = cnt;
            if (u == v)break;
        }
    }
}
```
