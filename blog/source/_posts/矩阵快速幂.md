---
title: 矩阵快速幂
date: 2025-08-16 17:41:31
---


### 一、算法实现

```c++
template<typename T, int M>
struct matrix_t {
    using row = vector<T>;
    using mat = vector<row>;
    using ll = long long;
    static void mul(const mat& a, const mat& b, mat& c) {
        auto m = a.size(), p = a[0].size(), n = b[0].size();
        for (int i = 0; i < m; ++i) {
            for (int k = 0; k < p; ++k) {
                for (int j = 0; j < n; ++j) {
                    c[i][j] = (c[i][j] + (ll)a[i][k] * b[k][j]) % M;
                }
            }
        }
    }
    static mat mul(const mat& a, const mat& b) {
        auto m = a.size(), n = b[0].size();
        mat c = vector<row>(m, row(n, 0));
        mul(a, b, c);
        return c;
    }
    static mat qpow(mat a, ll k) {
        auto n = a.size();
        mat ans = vector<row>(n, row(n, 0));
        for (int i = 0; i < n; ++i) {
            ans[i][i] = 1;
        }
        while (k) {
            if (k & 1) {
                ans = mul(a, ans);
            }
            k >>= 1;
            a = mul(a, a);
        }
        return ans;
    }
};
const int M = 1e9 + 7;
using matrix = matrix_t<int, M>;
class Solution {
public:
    int fib(int n) {
         vector<vector<int>> mat = {{0, 1}, {1, 1}};
         vector<vector<int>> vec = {{0, 1}};
         mat = matrix::qpow(mat, n);
         return matrix::mul(vec, mat)[0][0];
    }
};
```